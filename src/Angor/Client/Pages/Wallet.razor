@page "/wallet"
@using Blockcore.Consensus.BlockInfo
@using Blockcore.NBitcoin
@using Blockcore.NBitcoin.BIP32
@using Angor.Client.Shared.Models
@using Angor.Client.Shared.Types
@using Angor.Shared
@using Blockcore.NBitcoin.BIP39
@using Blockcore.Networks
@using Angor.Client.Services
@using Angor.Client.Storage

@inject HttpClient Http
@inject IClientStorage storage;
@inject IHdOperations HdOperations;
@inject ILogger<Wallet> Logger;
@inject INetworkConfiguration _networkConfiguration;
@inject IJSRuntime JsRuntime
@inject IWalletOperations _walletOperations;
@inject IWalletStorage _walletStorage;

<PageTitle>Wallet and balances</PageTitle>

<h1>Wallet and balances</h1>

<p class="alert-warning">Beta app only use test wallets!!!!!</p>

<p>Wallet Words.</p>

<textarea class="form-control" rows="3" @bind="walletWords" />

@if (hasWallet)
{
    <p><strong>Wallet Found</strong></p>
    <button class="btn btn-primary mb-3 mt-3" @onclick="ShowWallet">Show Wallet</button>
    <button class="btn btn-danger mb-3 mt-3" @onclick="DeleteWallet">Delete Wallet</button>
}
else
{
    <p><strong>No Wallet Found</strong></p>
    <button class="btn btn-primary mb-3 mt-3" @onclick="CreateWallet">Generate Wallet</button>    
    <button class="btn btn-primary mb-3 mt-3" @onclick="RestoreWallet">Restore Wallet</button>
}

<br/>
@*<select @bind="selectedNetwork"   type="text" @onchange="Callback" >*@
<p class="text-info mb-3 mt-3 fw-bold" >Select network:</p>

<button class="btn btn-primary" disabled="@busy" @onclick="Fetch">Refresh Balance</button>
<button class="btn btn-warning" @onclick="ClearAccount">Clear Balance</button>

<br/>
<p class="alert-info">@loadingStatus</p>
<p class="alert-danger">@erroMessage</p>

@if (localAccountInfo != null)
{
    <p class="text-info mb-3 mt-3 fw-bold">Send:</p>

    <input class="form-control mb-3 mt-3" @bind="sendToAddress" />
    <input class="form-control mb-3 mt-3" @bind="sendAmount" />
    <button class="btn btn-primary" disabled="@busy" @onclick="Send">Send</button>
    <br />


    <p class="text-info mb-3 mt-3 fw-bold">Receive:</p>

    @foreach (var item in @localAccountInfo.AddressesInfo)
    {
        if (!@item.Value.HasHistory)
        {
            <p >@item.Key</p>
            break;
        }
    }

    <p class="text-info mb-3 mt-3 fw-bold">Outputs:</p>

    <p> Account path @localAccountInfo.Path</p>
    <p> Total balance @Money.Satoshis(localAccountInfo.TotalBalance) @selectedNetwork</p>
    <p> Addressed scanned @scannedAcount</p>

    <table class="table table-bordered">
        <thead>
        <tr>
            <th>Address</th>
            <th>Amount</th>
        </tr>
        </thead>
        <tbody>
        
        @foreach (var (Address, addressInfo) in localAccountInfo.AddressesInfo)
        {
            var total = addressInfo.Balance;
            var count = addressInfo.UtxoData.Count();

            if (total > 0)
            {
                <tr @onclick="(_ => ShowRow(Address))" style="cursor: pointer;">
                    <td >@Address</td>
                    <td>@Money.Satoshis(total).ToUnit(MoneyUnit.BTC) @selectedNetwork</td>
                </tr>
             
                @if (collapses.ContainsKey(Address))
                {
                    <tr>
                        <td colspan="2" >
                            <div class="inner-table-inner-div">
                                <p>Path = @addressInfo.HdPath</p>
                                <p>Total outputs = @count</p>
                                    <table class="table inner-table inner-table-rounded">
                                    <tbody>
                                    @foreach (var addressUtxoItem in addressInfo.UtxoData)
                                    {
                                        <tr>
                                            <td>@($"{addressUtxoItem.outpoint.transactionId}-{addressUtxoItem.outpoint.outputIndex}")</td>
                                            <td>@Money.Satoshis(addressUtxoItem.value).ToUnit(MoneyUnit.BTC) @selectedNetwork </td>
                                        </tr>
                                    }
                                    </tbody>
                                </table>
                            </div>
                        </td>
                    </tr>
                }
            }
        }
        </tbody>
        <thead>
        <tr>
            <th>Address - change</th>
            <th>Amount</th>
        </tr>
        </thead>
        <tbody>
        @foreach (var (address, addressInfo) in localAccountInfo.ChangeAddressesInfo)
        {
            var total = addressInfo.Balance;
            var count = addressInfo.UtxoData.Count();

            if (total > 0)
            {
                <tr @onclick="(_ => ShowRow(address))" style="cursor: pointer;">
                    <td>@address</td>
                    <td>@Money.Satoshis(total).ToUnit(MoneyUnit.BTC) @selectedNetwork</td>
                </tr>

                @if (collapses.ContainsKey(address))
                {
                    <tr>
                        <td colspan="2" >
                            <div class="inner-table-inner-div">
                                <p>Path = @addressInfo.Balance</p>
                                <p>Total outputs = @count</p>
                                    <table class="table inner-table inner-table-rounded">
                                    <tbody>
                                        @foreach (var addressUtxoItem in addressInfo.UtxoData)
                                        {
                                            <tr>
                                                <td>@($"{addressUtxoItem.outpoint.transactionId}-{addressUtxoItem.outpoint.outputIndex}")</td>
                                                <td>@Money.Satoshis(addressUtxoItem.value).ToUnit(MoneyUnit.BTC) @selectedNetwork </td>
                                            </tr>
                                        }
                                    </tbody>
                                </table>
                            </div>
                        </td>
                    </tr>
                }
            }
        }

        </tbody>
    </table>
   
}

@code {
    private bool busy = false;
    private string sendToAddress;
    private decimal sendAmount;

    private string walletWords;
    private bool hasWallet;
    public string link { get; set; } = string.Empty;
    public int blockheight;
    public string outputs;
    Block block;
    Network network;
    private AccountInfo? localAccountInfo;

    string loadingStatus = string.Empty;
    string erroMessage = string.Empty;

    List<string> NetworkList;
    string selectedNetwork;
    int scannedAcount;

    protected override async Task OnInitializedAsync()
    {
        hasWallet = _walletStorage.HasWallet();
    }

    private async Task Send()
    {
        if (busy) return;
        busy = true;
        
        try
        {
            erroMessage = string.Empty;
            loadingStatus = $"Sending {sendAmount} coins to {sendToAddress}";
            StateHasChanged();
            await Task.Delay(1);

            var fees = await _walletOperations.GetFeeEstimationAsync();

            var fee = fees.First().FeeRateet;
            
            bool confirmed = await JsRuntime.InvokeAsync<bool>("confirm", $"The fee is {fee}, continue?");

            if (!confirmed)
                return;

            var res = await _walletOperations.SendAmountToAddress(sendAmount, fee, sendToAddress);

            if (!res.Success)
            {
                erroMessage = res.Message;
                StateHasChanged();
                await Task.Delay(1);
                throw new Exception(res.Message);
            }

            erroMessage = string.Empty;
            loadingStatus = $"Transaction Sent! - {sendAmount} coins to {sendToAddress} - trxid = {res.Message}";

        }
        catch (Exception ex)
        {
            erroMessage = ex.Message;
            throw;
        }
        finally
        {
            busy = false;
        }
    }

    private async Task Fetch()
    {
        if (busy) return;
        busy = true;
        try
        {
            ExtKey.UseBCForHMACSHA512 = true;
            Blockcore.NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;
            scannedAcount = 0;
            localAccountInfo = null;

            loadingStatus = "Loading key...";
            erroMessage = string.Empty;

            StateHasChanged();
            await Task.Delay(1);

            Network network = _networkConfiguration.GetNetwork();
            selectedNetwork = network.Name;
            var coinType = network.Consensus.CoinType;
            var accountIndex = 0; // for now only account 0
            var purpose = 84; // for now only legacy

            //var indexer = await storage.Indexer(selectedNetwork);

            AccountInfo accountInfo = storage.GetAccountInfo(selectedNetwork);

            localAccountInfo = accountInfo;

            loadingStatus = "Checking Addresses...";
            StateHasChanged();
            await Task.Delay(1);

            await CheckExistingAddresses(localAccountInfo);
            
            loadingStatus = "Fetching Addresses...";
            StateHasChanged();
            await Task.Delay(1);

            localAccountInfo = await _walletOperations.UpdateAccountInfo();
            
            erroMessage = String.Empty;
            loadingStatus = string.Empty;
            
            StateHasChanged();
            await Task.Delay(1);
        }
        catch (Exception ex)
        {
            erroMessage = ex.Message;
            throw;
        }
        finally
        {
            busy = false;
        }

    }

    private async Task CheckExistingAddresses(AccountInfo accountInfo)
    {
        foreach (var (address, addressInfo) in accountInfo.AddressesInfo)
        {
            if (!addressInfo.UtxoData.Any()) continue;
            
            var result = await _walletOperations.FetchUtxoForAddressAsync(address);

            if (result.data.Count == addressInfo.UtxoData.Count)
            {
                for (var i = 0; i < result.data.Count - 1; i++)
                {
                    if (result.data[i].outpoint.transactionId == addressInfo.UtxoData[i].outpoint.transactionId) 
                        continue;
                    addressInfo.UtxoData.Clear();
                    addressInfo.UtxoData.AddRange(result.data);
                    break;
                }
            }
            else
            {
                addressInfo.UtxoData.Clear();
                addressInfo.UtxoData.AddRange(result.data);
            }
        }

        foreach (var (changeAddress, addressInfo) in accountInfo.ChangeAddressesInfo)
        {
            if (!addressInfo.HasHistory) continue;
            
            var result = await _walletOperations.FetchUtxoForAddressAsync(changeAddress);

            if (result.data.Count == addressInfo.UtxoData.Count)
            {
                for (var i = 0; i < result.data.Count - 1; i++)
                {
                    if (result.data[i].outpoint.transactionId == addressInfo.UtxoData[i].outpoint.transactionId) 
                        continue;
                    addressInfo.UtxoData.Clear();
                    addressInfo.UtxoData.AddRange(result.data);
                    break;
                }
            }
            else
            {
                addressInfo.UtxoData.Clear();
                addressInfo.UtxoData.AddRange(result.data);
            }
        }
    }

    private async Task RestoreWallet()
    {
        if (walletWords == string.Empty)
        {
            erroMessage = "no wallet words found";
            StateHasChanged();
            await Task.Delay(1);
            return;
        }

        _walletStorage.SaveWalletWords(WalletWords.ConvertFromString(walletWords));
        await ClearAccount();
        _walletOperations.BuildAccountInfoForWalletWords();
        hasWallet = true;

        loadingStatus = string.Empty;
        erroMessage = string.Empty;
        StateHasChanged();
        await Task.Delay(1);
    }

    private async Task ShowWallet()
    {
        walletWords = _walletStorage.GetWalletWords() ?? string.Empty;
    }

    private async Task ClearAccount()
    {
        var account = storage.GetAccountInfo(selectedNetwork);
        if (account != null)
        {
            account.TotalBalance = 0;
            account.LastFetchChangeIndex = 0;
            account.LastFetchIndex = 0;
            account.AddressesInfo.Clear();
            account.ChangeAddressesInfo.Clear();
            storage.SetAccountInfo(selectedNetwork, account);
            localAccountInfo = account;
        }
    }

    private void Callback(ChangeEventArgs obj)
    {
        selectedNetwork = obj.Value.ToString();

        var accountInfo = storage.GetAccountInfo(selectedNetwork);
        scannedAcount = 0;
        if (accountInfo != null)
        {
            this.localAccountInfo = accountInfo;
        }
        else
        {
            this.localAccountInfo = null;
        }

        Console.WriteLine($"Account info balance {this.localAccountInfo?.TotalBalance ?? 0}");

    }

    private async Task CreateWallet()
    {
        var count = (WordCount)12;
        var mnemonic = new Mnemonic(Wordlist.English, count);
        walletWords = mnemonic.ToString();

        await RestoreWallet();

        localAccountInfo = null;

        loadingStatus = string.Empty;
        erroMessage = string.Empty;
        StateHasChanged();
        await Task.Delay(1);
    }

    private async Task DeleteWallet()
    {
        //Network network = _networkConfiguration.GetNetwork();
       
        storage.DeleteAccountInfo(selectedNetwork);
        _walletStorage.DeleteWalletWords();
        
        walletWords = string.Empty;
        localAccountInfo = null;
        hasWallet = false;

        loadingStatus = string.Empty;
        erroMessage = string.Empty;
        StateHasChanged();
        await Task.Delay(1);
    }

    Dictionary<string, string> collapses = new();

    private void ShowRow(string address)
    {
        if (collapses.ContainsKey(address))
            collapses.Remove(address);
        else
            collapses.Add(address, null);
    }
}
